#### 8-7 [457. Circular Array Loop](https://leetcode-cn.com/problems/circular-array-loop/)

> You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:
>
> If nums[i] is positive, move nums[i] steps forward, and
> If nums[i] is negative, move nums[i] steps backward.
> Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.
>
> A cycle in the array consists of a sequence of indices seq of length k where:
>
> Following the movement rules above results in the repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
> Every nums[seq[j]] is either all positive or all negative.
> k > 1
> Return true if there is a cycle in nums, or false otherwise.

```
class Solution {
public:
    bool circularArrayLoop(vector<int>& nums) {
        if(nums.size()<2) return false;
        int slow,fast,n=nums.size();
        auto next=[&](int x)->int{
            return ((x+nums[x])%n+n)%n;
        };
        for(int i=0;i<n;i++){
            slow=i;
            fast=next(slow);
            cout<<slow<<"???"<<fast<<endl;
            while(nums[slow]*nums[fast]>0&&nums[slow]*nums[next(slow)]>0){
                cout<<slow<<"II"<<fast<<endl;
                if(slow==fast){
                    cout<<slow<<endl;
                    if(slow!=next(slow)){
                        return true;
                    }
                    break;
                }
                slow=next(slow);
                fast=next(next(fast));
            }
            int temp=i;
            while(nums[temp]*nums[next(temp)]>0){
                int net=next(temp);
                nums[temp]=0;
                temp=net;
            }
        }
        return false;
    }
};
```

```

```

#### 8-8 [1137. N-th Tribonacci Number](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

> The Tribonacci sequence Tn is defined as follows: 
>
> T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
>
> Given n, return the value of Tn.

```c++
class Solution {
public:
    int tribonacci(int n) {
        if(n==0) return n;
        if(n==1||n==2) return 1;
        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);
    }
};
```

```c++
class Solution {
public:
    int tribonacci(int n) {
        if(n<2) return n;
        vector<int> dp(n+1);
        dp[0]=0;
        dp[1]=dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
};
```

```c++
class Solution {
public:
    int tribonacci(int n) {
        if(n<2) return n;
        int p,q,r;
        p=0;
        q=r=1;
        for(int i=3;i<=n;i++){
            int temp=p+q+r;
            p=q;
            q=r;
            r=temp;
        }
        return r;
    }
};
```

#### 8-9 [313. Super Ugly Number](https://leetcode-cn.com/problems/super-ugly-number/)

> A super ugly number is a positive integer whose prime factors are in the array primes.
>
> Given an integer n and an array of integers primes, return the nth super ugly number.
>
> The nth super ugly number is guaranteed to fit in a 32-bit signed integer.

```c++
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        set<long> duplicate;
        priority_queue<long,vector<long>,greater<long>> q;
        int i,j;
        q.push(1);
        duplicate.insert(1);
        for(i=0;i<n-1;i++){
            long k=q.top();
            q.pop();
            for(j=0;j<primes.size();j++){
                if(!duplicate.count(primes[j]*k)){
                    q.push(primes[j]*k);
                    duplicate.insert(primes[j]*k);
                }    
            }
        }
        return q.top();
    }
};
```

#### 8-10 [413. Arithmetic Slices](https://leetcode-cn.com/problems/arithmetic-slices/)

> An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
>
> For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.
> Given an integer array nums, return the number of arithmetic subarrays of nums.
>
> A subarray is a contiguous subsequence of the array.
>

```c++
class Solution {
public:
    unordered_map<int,int> record;
    int calculate(int n){
        if(n<3) return 0;
        if(record[n]) return record[n];
        int sum=0;
        // Cn3+Cn4+...+Cnn
        for(int i=3;i<=n;i++){
            sum+=n-i+1;
        }
        record[n]=sum;
        return sum;
    }
    int numberOfArithmeticSlices(vector<int>& nums) {
        if(nums.size()<3) return 0;
        int i,j,res=0;
        i=0,j=1;
        while(j<nums.size()){
            int minus=nums[j]-nums[j-1];
            j++;
            while(j<nums.size()&&minus==nums[j]-nums[j-1]){
                j++;
            }
            if(j-i>2){
                res+=calculate(j-i);
                i=j-1;
            }else{
                i++;
                j=i+1;
            }
        }
        return res;
    }
};
```

#### 8-12 [516. Longest Palindromic Subsequence](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

> Given a string s, find the longest palindromic subsequence's length in s.
>
> A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.
>
> ```
> s = "bbbab"
> output:4 "bbbb"
> ```

这个问题对 dp 数组的定义是：在子串`s[i..j]`中，最长回文子序列的长度为`dp[i][j]`

从已知推向未知：要求`dp[i][j]`的值，我们可以借助`dp[i+1][j-1]`的值，可以简单得知，如果`s[i]==s[j]`，那么`dp[i][j]=dp[i+1][j-1]+2`；如果`s[i]!=s[j]`说明它俩不可能同时出现在`s[i..j]`的最长回文子序列中，那么把它俩分别加入`s[i+1..j-1]`中，看看哪个子串产生的回文子序列更长即可，那么`dp[i][j]=max(dp[i+1][j],dp[i][j-1])`

我们考虑一下base case的值，如果只有一个字符，那么最长子序列的值为1，因为`i<=j`必然成立，所以对于`i>j`的情况，值应该初始化为0。

![solution](./516.png)

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n=s.size();
        vector<vector<int>> dp(n,vector<int>(n,0));
        for(int i=0;i<n;i++){
            dp[i][i]=1;
        }
        for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s[i]==s[j]){
                    dp[i][j]=dp[i+1][j-1]+2;
                }else{
                    dp[i][j]=std::max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

8-13 [233. Number of Digit One](https://leetcode-cn.com/problems/number-of-digit-one/)

> Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

设数字n是个x位数，记n的第i位为ni，则n=nxnx-1……n2n1

ni为当前位置，记为cur

ni-1…n2n1为低位，记为low

nxnx-1…ni+1称为高位，记为high

将10^i称为位因子，记为digit

根据cur的值，分为以下三种情况：

cur=0，1的出现次数由high决定，high*digit

![233-Picture1](233-Picture1.png)

cur=1,1的出现次数由高低位共同决定,high*digit+low+1

![233-Picture2](233-Picture2.png)

cur=2,3……9，1的出现次数只由高位决定，(high+1)*digit

![233-Picture3](233-Picture3.png)

```c++
class Solution {
public:
    int countDigitOne(int n) {
        long digit=1;
        int res = 0;
        int high=n/10;
        int cur=n%10;
        int low = 0;
        while(!(high==0&&cur==0)){
            if(cur==0){
                res+=high*digit;
            }else if(cur==1){
                res+=high*digit+low+1;
            }else{
                res+=(high+1)*digit;
            }
            low+=cur * digit;
            cur=high % 10;
            high/=10;
            digit*=10;
        }
        return res;
    }
};

```

8-14 [1583. Count Unhappy Friends](https://leetcode-cn.com/problems/count-unhappy-friends/)

> You are given a list of preferences for n friends, where n is always even.
>
> For each person i, preferences[i] contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from 0 to n-1.
>
> All the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi.
>
> However, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:
>
> x prefers u over y, and
> u prefers x over v.
> Return the number of unhappy friends.

用哈希表来记录对于每一个小朋友比起当前的伙伴更喜欢的小朋友，随后去查看每一个小朋友，遍历他的更喜欢的列表，如果对应小朋友的列表也有他，那么他俩就都是不开心的。

`0:[]`

`1:[3,2]`

`2:[]`

`3:[1]`

```c++
class Solution {
public:
    vector<int> findMorePre(vector<int> preList,int fri){
        int i;
        for(i=0;i<preList.size();i++){
            if(preList[i]==fri) break;
        }
        return {preList.begin(),preList.begin()+i};
    }
    bool findFriend(vector<int> preList,int fri){
        for(int i=0;i<preList.size();i++){
            if(preList[i]==fri) return true;
        }
        return false;
    }
    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {
        int i,j;
        set<int> unhappy;
        unordered_map<int,vector<int>> recordPair;
        for(i=0;i<pairs.size();i++){
            recordPair[pairs[i][0]]=findMorePre(preferences[pairs[i][0]],pairs[i][1]);
            recordPair[pairs[i][1]]=findMorePre(preferences[pairs[i][1]],pairs[i][0]);
        }
        for(i=0;i<n;i++){
            if(unhappy.count(i)) continue;
            vector<int> morePre=recordPair[i];
            if(!morePre.size()) continue;
            for(int each:morePre){
                if(findFriend(recordPair[each],i)){
                    unhappy.insert(i);
                    unhappy.insert(each);
                }
            }

        }
        return unhappy.size();    
    }
};
```

创建 n 行 n 列的二维数组list，其中`list[i][j]`表示朋友j在i的朋友列表中的亲近程度下标。遍历preferences 即可填入list中的全部元素的值。

所有的朋友被分成n/2对，为了快速知道每位朋友的配对的朋友，对于配对情况也需要进行预处理。创建长度为n的数组match，如果x和y配对，则有`macth[x]=y`以及`match[y]=x`。

进行预处理之后，即可统计不开心的朋友的数目。

遍历从0到n-1的每位朋友x，进行如下操作。

1. 找到与朋友x配对的朋友y。
2. 找到朋友 y 在朋友 x 的朋友列表中的亲近程度下标，记为index。
3. 朋友 x 的朋友列表中的下标从 0 到 index−1 的朋友都是可能的 u。遍历每个可能的 u，找到与朋友 u 配对的朋友 v。
4. `list[u][x]<list[u][v]`，则 x 是不开心的朋友。

```c++
class Solution {
public:
    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {
        vector<vector<int>> list(n,vector<int>(n));
        int i,j;
        int unhappy=0;
        for(i=0;i<n;i++){
            for(j=0;j<n-1;j++){
                list[i][preferences[i][j]]=j;
            }
        }
        vector<int> match(n);
        for(i=0;i<pairs.size();i++){
            match[pairs[i][0]]=pairs[i][1];
            match[pairs[i][1]]=pairs[i][0];  
        }
        for(i=0;i<n;i++){
            int index=list[i][match[i]];
            for(j=0;j<index;j++){
                int u=preferences[i][j];
                int v=match[u];
                if(list[u][i]<list[u][v]){
                    unhappy++;
                    break;
                }
            }
        }
        return unhappy;
    }
};
```

